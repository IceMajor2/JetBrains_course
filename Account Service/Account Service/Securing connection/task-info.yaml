type: edu
files:
- name: src/account/AccountServiceApplication.java
  visible: true
  text: |-
    package account;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class AccountServiceApplication {

        public static void main(String[] args) {
            SpringApplication.run(AccountServiceApplication.class, args);
        }

    }
  learner_created: false
- name: src/resources/application.properties
  visible: true
  text: |-
    server.port=28852
    management.endpoints.web.exposure.include=*
    management.endpoint.shutdown.enabled=true
    spring.jackson.serialization.INDENT_OUTPUT=true
  learner_created: false
- name: build.gradle
  visible: true
  text: |-
    plugins {
        id 'java'
        id 'org.springframework.boot' version '2.3.1.RELEASE'
        id 'io.spring.dependency-management' version '1.0.9.RELEASE'
    }

    repositories {
        mavenCentral()
    }

    sourceSets.main.resources.srcDirs = ["src/resources"]

    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter'
        implementation 'org.springframework.boot:spring-boot-starter-actuator'
        implementation 'org.springframework.boot:spring-boot-starter-web'
        implementation 'com.h2database:h2'
        implementation group: 'org.hibernate', name: 'hibernate-validator', version: '6.1.0.Final'
    }
  learner_created: false
- name: test/AccountServiceTest.java
  visible: false
  text: |
    import account.AccountServiceApplication;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.dynamic.input.DynamicTesting;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.mocks.web.request.HttpRequest;
    import org.hyperskill.hstest.stage.SpringTest;
    import org.hyperskill.hstest.testcase.CheckResult;

    import javax.net.ssl.*;
    import java.security.cert.X509Certificate;

    public class AccountServiceTest extends SpringTest {
      public AccountServiceTest() {
        super(AccountServiceApplication.class, "../service_db.mv.db");
      }

      SSLSocket socket;
      java.security.cert.X509Certificate[] chain;

      // Warning!!! Only for testing reason, trust all certificates!
      TrustManager[] trustAllCerts = new TrustManager[] {
              new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                  return new java.security.cert.X509Certificate[0];
                }
                public void checkClientTrusted(
                        java.security.cert.X509Certificate[] certs, String authType) {
                }
                public void checkServerTrusted(
                        java.security.cert.X509Certificate[] certs, String authType) {
                }
              }
      };

      // Test SSL
      public CheckResult checkCertificateName(String nameCN) {
        try {
          SSLContext sc = SSLContext.getInstance("SSL");
          //ТАК нельзя!!! доверяем всем сертификатам, только для тестирования и разработки!!!
          sc.init(null, trustAllCerts, new java.security.SecureRandom());
          SSLSocketFactory factory = sc.getSocketFactory();
          HttpRequest request = get("");
          socket = (SSLSocket) factory.createSocket(request.getHost(), request.getPort());
          getCertificates();
          if (findCert(nameCN)) {
            return CheckResult.correct();
          } else {
            throw new WrongAnswer("Not found certificate with CN - " + nameCN);
          }
        } catch (Exception e) {
          e.printStackTrace();
          System.out.println("Connection not found");
          throw new WrongAnswer("Can't establish https connection!");
        }
      }

      // Get certificate chain
      public void getCertificates() {
        try {
          chain = (X509Certificate[]) socket.getSession().getPeerCertificates();
        } catch (SSLPeerUnverifiedException e) {
          e.printStackTrace();
          System.out.println(e.toString());
        }
      }


      // Searching certificate by Common Name
      public boolean findCert(String subject) {
        for (java.security.cert.X509Certificate c : chain) {
          String subjectName = c.getSubjectDN().getName();
          System.out.println(subjectName + " " + c.getSigAlgName());
          if (subjectName.contains("CN=" + subject)) {
            return true;
          }
        }
        return false;
      }

      @DynamicTest
      DynamicTesting[] dt = new DynamicTesting[]{

              // Check certificate name
              () -> checkCertificateName("accountant_service"),
      };
    }
  learner_created: false
- name: src/account/exceptions/business/PaymentMadeForPeriodException.java
  visible: true
  text: |
    package account.exceptions.business;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "Payment for that period was already made!")
    public class PaymentMadeForPeriodException extends RuntimeException {
    }
  learner_created: true
- name: src/account/controllers/AdminController.java
  visible: true
  text: |
    package account.controllers;

    import account.DTO.RoleDTO;
    import account.DTO.UserActionDTO;
    import account.exceptions.ApiError;
    import account.models.User;
    import account.services.AdminService;
    import account.services.SecurityLogService;
    import jakarta.validation.Valid;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.access.prepost.PreAuthorize;
    import org.springframework.security.core.annotation.AuthenticationPrincipal;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.web.bind.annotation.*;
    import org.springframework.web.context.request.ServletWebRequest;
    import org.springframework.web.context.request.WebRequest;

    import java.util.Map;

    @RestController
    @RequestMapping("/api/admin")
    public class AdminController {

        @Autowired
        private AdminService adminService;
        @Autowired
        private SecurityLogService securityLogService;

        @PutMapping(value = {"/user/role", "/user/role/"})
        @PreAuthorize("hasAuthority('ROLE_ADMINISTRATOR')")
        public ResponseEntity changeUserRole(@AuthenticationPrincipal UserDetails details,
                                             @RequestBody @Valid RoleDTO roleDTO) {
            User user = adminService.changeRole(roleDTO);
            securityLogService.saveRoleChangedLog(details, user, roleDTO);
            return ResponseEntity.ok(user);
        }

        @DeleteMapping(value = {"/user/{email}", "/user", "/user/"})
        @PreAuthorize("hasAuthority('ROLE_ADMINISTRATOR')")
        public ResponseEntity deleteUser(@AuthenticationPrincipal UserDetails details,
                                         @PathVariable String email) {
            User deletedUsr = adminService.deleteUser(email);
            securityLogService.saveAccountDeletedLog(details, deletedUsr);
            return ResponseEntity.ok(Map.of("user", deletedUsr.getEmail(),
                    "status", "Deleted successfully!"));
        }

        @GetMapping(value = {"/user", "/user/"})
        @PreAuthorize("hasAuthority('ROLE_ADMINISTRATOR')")
        public ResponseEntity usersInfo() {
            var users = adminService.getUsersList();
            return ResponseEntity.ok(users);
        }

        @PutMapping(value = {"/user/access", "/user/access/"})
        @PreAuthorize("hasAuthority('ROLE_ADMINISTRATOR')")
        public ResponseEntity lockUnlockUser(@AuthenticationPrincipal UserDetails details,
                                             @RequestBody @Valid UserActionDTO userActionDTO) {
            User user = adminService.lockUnlockUser(userActionDTO);
            securityLogService.saveAccountLockLog(details, user, userActionDTO);
            return ResponseEntity.ok(Map.of("status", "User %s %s!"
                    .formatted(user.getEmail(),
                            userActionDTO.getOperation().toString().toLowerCase() + "ed")));
        }

        @ExceptionHandler(IllegalArgumentException.class)
        public ResponseEntity handleRoleNotFound(
                RuntimeException ex, WebRequest request) {
            HttpStatus status = HttpStatus.NOT_FOUND;
            String message = "Role not found!";
            String path = ((ServletWebRequest) request).getRequest().getRequestURI();

            ApiError error = new ApiError(status, message, path);
            return ResponseEntity.status(status).body(error);
        }
    }
  learner_created: true
- name: src/account/exceptions/ApiError.java
  visible: true
  text: |-
    package account.exceptions;

    import org.springframework.http.HttpStatus;

    import java.time.LocalDateTime;

    public class ApiError {

        private LocalDateTime timestamp;
        private int status;
        private String error;
        private String message;
        private String path;

        public ApiError(HttpStatus status, String message, String path) {
            super();
            this.timestamp = LocalDateTime.now();
            this.status = status.value();
            this.error = status.getReasonPhrase();
            this.message = message;
            this.path = path;
        }

        public LocalDateTime getTimestamp() {
            return timestamp;
        }

        public void setTimestamp(LocalDateTime timestamp) {
            this.timestamp = timestamp;
        }

        public int getStatus() {
            return status;
        }

        public void setStatus(int status) {
            this.status = status;
        }

        public String getError() {
            return error;
        }

        public void setError(String error) {
            this.error = error;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }

        public String getPath() {
            return path;
        }

        public void setPath(String path) {
            this.path = path;
        }
    }
  learner_created: true
- name: src/account/exceptions/roles/AdminDeletionException.java
  visible: true
  text: |
    package account.exceptions.roles;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "Can't remove ADMINISTRATOR role!")
    public class AdminDeletionException extends RuntimeException {
    }
  learner_created: true
- name: src/account/repositories/SecurityLogRepository.java
  visible: true
  text: |
    package account.repositories;

    import account.models.SecurityLog;
    import org.springframework.data.repository.CrudRepository;

    import java.util.List;

    public interface SecurityLogRepository extends CrudRepository<SecurityLog, Long> {

        List<SecurityLog> findAllByOrderByIdAsc();
    }
  learner_created: true
- name: src/account/DTO/RoleDTO.java
  visible: true
  text: |
    package account.DTO;

    import account.enums.OperationType;
    import com.fasterxml.jackson.annotation.JsonProperty;
    import jakarta.persistence.EnumType;
    import jakarta.persistence.Enumerated;
    import jakarta.validation.constraints.NotEmpty;

    public class RoleDTO {

        @JsonProperty("user")
        @NotEmpty
        private String email;

        private String role;

        @Enumerated(EnumType.STRING)
        private OperationType operation;

        public String getEmail() {
            return email;
        }

        public void setEmail(String email) {
            this.email = email;
        }

        public String getRole() {
            return role;
        }

        public void setRole(String role) {
            this.role = role;
        }

        public OperationType getOperation() {
            return operation;
        }

        public void setOperation(OperationType operation) {
            this.operation = operation;
        }
    }
  learner_created: true
- name: src/account/services/UserDetailsServiceImpl.java
  visible: true
  text: |-
    package account.services;

    import account.repositories.UserRepository;
    import account.security.UserDetailsImpl;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.security.core.userdetails.UserDetailsService;
    import org.springframework.security.core.userdetails.UsernameNotFoundException;
    import org.springframework.stereotype.Service;
    import account.models.User;

    import java.util.Optional;

    @Service
    public class UserDetailsServiceImpl implements UserDetailsService {

        @Autowired
        private UserRepository userRepository;

        @Override
        public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
            Optional<User> user = userRepository.findByEmailIgnoreCase(email);
            return user.map(UserDetailsImpl::new)
                    .orElseThrow(() -> new UsernameNotFoundException
                            ("User '%s' was not found".formatted(email)));
        }
    }
  learner_created: true
- name: src/account/exceptions/roles/RoleNotFoundException.java
  visible: true
  text: |
    package account.exceptions.roles;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "The user does not have a role!")
    public class RoleNotFoundException extends RuntimeException {
    }
  learner_created: true
- name: src/account/exceptions/roles/TooLittleRolesException.java
  visible: true
  text: |
    package account.exceptions.roles;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "The user must have at least one role!")
    public class TooLittleRolesException extends RuntimeException {
    }
  learner_created: true
- name: src/account/exceptions/CustomRestExceptionHandler.java
  visible: true
  text: |-
    package account.exceptions;

    import jakarta.validation.ConstraintViolation;
    import jakarta.validation.ConstraintViolationException;
    import org.springframework.core.Ordered;
    import org.springframework.core.annotation.Order;
    import org.springframework.http.HttpHeaders;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.HttpStatusCode;
    import org.springframework.http.ResponseEntity;
    import org.springframework.validation.FieldError;
    import org.springframework.web.bind.MethodArgumentNotValidException;
    import org.springframework.web.bind.annotation.ExceptionHandler;
    import org.springframework.web.bind.annotation.RestControllerAdvice;
    import org.springframework.web.context.request.ServletWebRequest;
    import org.springframework.web.context.request.WebRequest;
    import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.Set;

    @Order(Ordered.HIGHEST_PRECEDENCE)
    @RestControllerAdvice
    public class CustomRestExceptionHandler extends ResponseEntityExceptionHandler {

        @Override
        protected ResponseEntity<Object> handleMethodArgumentNotValid
                (MethodArgumentNotValidException ex,
                 HttpHeaders headers,
                 HttpStatusCode status,
                 WebRequest request) {

            List<String> errors = new ArrayList<String>();
            for (FieldError error : ex.getBindingResult().getFieldErrors()) {
                errors.add(error.getDefaultMessage());
            }
            String path = ((ServletWebRequest) request).getRequest().getRequestURI();
            ApiError apiError =
                    new ApiError(HttpStatus.BAD_REQUEST, errors.get(0), path);
            return handleExceptionInternal
                    (ex, apiError, headers, ex.getStatusCode(), request);
        }

        @ExceptionHandler(ConstraintViolationException.class)
        public ResponseEntity<ApiError> handleConstraintViolationException
                (ConstraintViolationException exception, WebRequest request) {
            HttpStatus status = HttpStatus.BAD_REQUEST;
            String message = getMessage(exception.getConstraintViolations());
            String path = ((ServletWebRequest) request).getRequest().getRequestURI();

            ApiError error = new ApiError(status, message, path);
            return ResponseEntity.badRequest().body(error);
        }

        private String getMessage(Set<ConstraintViolation<?>> violations) {
            StringBuilder message = new StringBuilder("");
            var excIterator = violations.stream().iterator();
            while(excIterator.hasNext()) {
                var violation = excIterator.next();
                message.append(violation.getMessage()).append("; ");
            }
            return message.delete(message.length() - 2, message.length()).toString();
        }
    }
  learner_created: true
- name: src/account/exceptions/auth/UserNotFoundException.java
  visible: true
  text: |
    package account.exceptions.auth;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.NOT_FOUND, reason = "User not found!")
    public class UserNotFoundException extends RuntimeException {
    }
  learner_created: true
- name: src/account/DTO/UserActionDTO.java
  visible: true
  text: |
    package account.DTO;

    import account.enums.AccountAction;
    import com.fasterxml.jackson.annotation.JsonProperty;
    import jakarta.persistence.EnumType;
    import jakarta.persistence.Enumerated;
    import jakarta.validation.constraints.NotEmpty;

    public class UserActionDTO {

        @NotEmpty
        @JsonProperty("user")
        private String email;
        @Enumerated(EnumType.STRING)
        private AccountAction operation;

        public String getEmail() {
            return email;
        }

        public void setEmail(String email) {
            this.email = email;
        }

        public AccountAction getOperation() {
            return operation;
        }

        public void setOperation(AccountAction operation) {
            this.operation = operation;
        }
    }
  learner_created: true
- name: src/account/security/SecurityConfig.java
  visible: true
  text: |
    package account.security;

    import account.exceptions.CustomRestExceptionHandler;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
    import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
    import org.springframework.security.config.http.SessionCreationPolicy;
    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.security.web.SecurityFilterChain;
    import org.springframework.security.web.access.AccessDeniedHandler;

    import static org.springframework.boot.autoconfigure.security.servlet.PathRequest.toH2Console;

    @EnableWebSecurity
    @EnableMethodSecurity(prePostEnabled = true)
    @Configuration
    public class SecurityConfig {

        @Autowired
        private RestAuthenticationEntryPoint restAuthenticationEntryPoint;

        @Bean
        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
            http
                    .httpBasic(httpBasic -> httpBasic
                            .authenticationEntryPoint(restAuthenticationEntryPoint))
                    .exceptionHandling(exceptionHandler -> exceptionHandler.accessDeniedHandler(getAccessDeniedHandler()))
                    .csrf((csrf) -> csrf.disable())
                    .headers(headers -> headers
                            .frameOptions(frameOptionsConfig -> frameOptionsConfig.disable()))
                    .authorizeHttpRequests((authz) -> authz
                            // controller-specific endpoints
                            .requestMatchers("/api/auth/signup/", "/api/auth/signup").permitAll()
                            .requestMatchers("/api/acct/payments/", "/api/acct/payments").hasAuthority("ROLE_ACCOUNTANT")
                            .requestMatchers("/api/admin/**").hasAuthority("ROLE_ADMINISTRATOR")
                            // other endpoints
                            .requestMatchers("/error").permitAll()
                            .requestMatchers(toH2Console()).permitAll()
                            .requestMatchers("/actuator/shutdown").permitAll()
                            .anyRequest().authenticated()
                    ).sessionManagement(sessionManagement -> sessionManagement
                            .sessionCreationPolicy(SessionCreationPolicy.STATELESS));
            return http.build();
        }

        @Bean
        public PasswordEncoder getEncoder() {
            return new BCryptPasswordEncoder(13);
        }

        @Bean
        public AccessDeniedHandler getAccessDeniedHandler(){
            return new CustomAccessDeniedHandler();
        }
    }
  learner_created: true
- name: src/account/models/User.java
  visible: true
  text: |
    package account.models;

    import account.DTO.UserDTO;
    import account.enums.Roles;
    import com.fasterxml.jackson.annotation.JsonIgnore;
    import com.fasterxml.jackson.annotation.JsonProperty;
    import jakarta.persistence.*;
    import jakarta.validation.constraints.NotEmpty;

    import java.io.Serializable;
    import java.util.ArrayList;
    import java.util.Comparator;
    import java.util.List;

    @Entity
    @Table(name = "users")
    public class User implements Serializable {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        @NotEmpty
        private String name;
        @NotEmpty
        @JsonProperty("lastname")
        private String lastName;
        @NotEmpty
        @Column(unique = true)
        private String email;
        @NotEmpty
        @JsonIgnore
        private String password;
        @NotEmpty
        @JsonProperty("roles")
        private List<Roles> roles;
        @JsonIgnore
        private boolean accountNonLocked = true;

        public User(UserDTO userDTO) {
            this.name = userDTO.getName();
            this.lastName = userDTO.getLastname();
            this.email = userDTO.getEmail().toLowerCase();
            this.password = userDTO.getPassword();
            this.roles = new ArrayList<>();
        }

        public User() {}

        public List<Roles> getRoles() {
            roles.sort(Comparator.naturalOrder());
            return roles;
        }

        public void setRoles(List<Roles> roles) {
            this.roles = roles;
        }

        public void addRole(Roles role) {
            this.roles.add(role);
        }

        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getLastName() {
            return lastName;
        }

        public void setLastName(String lastName) {
            this.lastName = lastName;
        }

        public String getEmail() {
            return email;
        }

        public void setEmail(String email) {
            this.email = email;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }

        public boolean isAccountNonLocked() {
            return accountNonLocked;
        }

        public void setAccountNonLocked(boolean accountNonLocked) {
            this.accountNonLocked = accountNonLocked;
        }

        @JsonIgnore
        public boolean isAdmin() {
            return roles.contains(Roles.ROLE_ADMINISTRATOR);
        }

        public boolean hasRole(Roles role) {
            return this.roles.contains(role);
        }

        public int rolesCount() {
            return this.roles.size();
        }

        public void removeRole(Roles role) {
            this.roles.remove(role);
        }
    }
  learner_created: true
- name: src/account/enums/Roles.java
  visible: true
  text: |
    package account.enums;

    public enum Roles {
        ROLE_ACCOUNTANT(false), ROLE_ADMINISTRATOR(true), ROLE_AUDITOR(false), ROLE_USER(false);

        private boolean admin;

        private Roles(boolean isAdmin) {
            this.admin = isAdmin;
        }

        public boolean isAdmin() {
            return admin;
        }

        public String noPrefix() {
            return this.toString().substring(5);
        }
    }
  learner_created: true
- name: src/account/services/AuthService.java
  visible: true
  text: |
    package account.services;

    import account.DTO.NewPasswordDTO;
    import account.DTO.UserDTO;
    import account.enums.Roles;
    import account.exceptions.auth.BreachedPasswordException;
    import account.exceptions.auth.PasswordNotChangedException;
    import account.exceptions.auth.UserExistsException;
    import account.models.User;
    import account.repositories.BreachedPasswordsRepository;
    import account.repositories.UserRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.stereotype.Service;

    @Service
    public class AuthService {

        @Autowired
        private UserRepository userRepository;
        @Autowired
        private BreachedPasswordsRepository breachedPasswordsRepository;
        @Autowired
        private PasswordEncoder passwordEncoder;

        public User registerUser(UserDTO userDTO) {
            passwordBreachedCondition(userDTO.getPassword());
            userExistsCondition(userDTO.getEmail());

            User user = new User(userDTO);
            assignRole(user);
            user.setPassword(passwordEncoder.encode(user.getPassword()));

            userRepository.save(user);
            return user;
        }

        public User changePassword(UserDetails userDetails, NewPasswordDTO newPasswordDTO) {
            passwordBreachedCondition(newPasswordDTO.getPassword());
            User user = userRepository.findByEmailIgnoreCase(userDetails.getUsername()).get();
            differentPasswordCondition(user.getPassword(), newPasswordDTO.getPassword());

            user.setPassword(passwordEncoder.encode(newPasswordDTO.getPassword()));
            userRepository.save(user);
            return user;
        }

        private void assignRole(User user) {
            if (userRepository.count() == 0) {
                user.addRole(Roles.ROLE_ADMINISTRATOR);
                return;
            }
            user.addRole(Roles.ROLE_USER);
        }

        private void passwordBreachedCondition(String password) {
            var optPass = breachedPasswordsRepository.findByPassword(password);
            if (optPass.isPresent()) {
                throw new BreachedPasswordException();
            }
        }

        private void userExistsCondition(String email) {
            if (userRepository.findByEmailIgnoreCase(email).isPresent()) {
                throw new UserExistsException();
            }
        }

        private void differentPasswordCondition(String usrPassHash, String newPass) {
            if (passwordEncoder.matches(newPass, usrPassHash)) {
                throw new PasswordNotChangedException();
            }
        }
    }
  learner_created: true
- name: src/account/services/BusinessService.java
  visible: true
  text: |
    package account.services;

    import account.DTO.AuthPaymentDTO;
    import account.DTO.PaymentDTO;
    import account.exceptions.business.NoSuchPaymentException;
    import account.exceptions.business.PaymentMadeForPeriodException;
    import account.exceptions.auth.UserNotExistsException;
    import account.models.Payment;
    import account.models.User;
    import account.repositories.PaymentRepository;
    import account.repositories.UserRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import java.text.ParseException;
    import java.text.SimpleDateFormat;
    import java.util.ArrayList;
    import java.util.Date;
    import java.util.List;

    @Service
    public class BusinessService {

        @Autowired
        private PaymentRepository paymentRepository;
        @Autowired
        private UserRepository userRepository;

        public AuthPaymentDTO getPayrolls(UserDetails userDetails, String period) {
            try {
                Date date = new SimpleDateFormat("MM-yyyy").parse(period);
                User user = userRepository.findByEmailIgnoreCase(userDetails.getUsername()).get();
                Payment payment = paymentRepository.findByUserIdAndPeriod(user.getId(), date)
                        .orElseThrow(() -> new NoSuchPaymentException());
                return new AuthPaymentDTO(user.getName(), user.getLastName(),
                        payment.getPeriod(), payment.getSalary());
            } catch (ParseException exception) {
                throw new RuntimeException(exception);
            }
        }

        public List<AuthPaymentDTO> getPayrolls(UserDetails userDetails) {
            User user = userRepository.findByEmailIgnoreCase(userDetails.getUsername()).get();
            List<Payment> payments = paymentRepository.findByUserIdOrderByPeriodDesc(user.getId());
            return convertPaymentListToDTOList(payments);
        }

        @Transactional
        public void uploadPayrolls(List<PaymentDTO> paymentDTOS) {
            for (PaymentDTO paymentDTO : paymentDTOS) {
                User user = userRepository.findByEmailIgnoreCase(paymentDTO.getEmail())
                        .orElseThrow(() -> new UserNotExistsException());

                Payment payment = null;
                try {
                    payment = new Payment(paymentDTO, user);
                } catch (ParseException exception) {
                    throw new RuntimeException(exception);
                }

                if (!isPaymentUnique(payment)) {
                    throw new PaymentMadeForPeriodException();
                }

                paymentRepository.save(payment);
            }
        }

        public void updatePayment(PaymentDTO paymentDTO) {
            User user = userRepository.findByEmailIgnoreCase(paymentDTO.getEmail())
                    .orElseThrow(() -> new UserNotExistsException());
            try {
                Date date = new SimpleDateFormat("MM-yyyy").parse(paymentDTO.getPeriod());
                Payment dbPayment = paymentRepository.findByUserIdAndPeriod(user.getId(), date)
                        .orElseThrow(() -> new NoSuchPaymentException());
                dbPayment.setSalary(paymentDTO.getSalary());
                paymentRepository.save(dbPayment);
            } catch (ParseException exception) {
                throw new RuntimeException(exception);
            }
        }

        private boolean isPaymentUnique(Payment payment) {
            User user = payment.getUser();
            List<Payment> payments = paymentRepository.findByUserId(user.getId());
            for (Payment paymentObj : payments) {
                if (paymentObj.getPeriod().equals(payment.getPeriod())) {
                    return false;
                }
            }
            return true;
        }

        private List<AuthPaymentDTO> convertPaymentListToDTOList(List<Payment> payments) {
            List<AuthPaymentDTO> authPaymentDTOS = new ArrayList<>();
            for (Payment payment : payments) {
                AuthPaymentDTO authPaymentDTO = new AuthPaymentDTO(payment);
                authPaymentDTOS.add(authPaymentDTO);
            }
            return authPaymentDTOS;
        }
    }
  learner_created: true
- name: src/account/exceptions/business/NoSuchPaymentException.java
  visible: true
  text: |
    package account.exceptions.business;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "Cannot find payment for a given period!")
    public class NoSuchPaymentException extends RuntimeException{
    }
  learner_created: true
- name: src/account/security/CustomAccessDeniedHandler.java
  visible: true
  text: |
    package account.security;

    import account.enums.SecurityAction;
    import account.models.SecurityLog;
    import account.services.SecurityLogService;
    import jakarta.servlet.http.HttpServletRequest;
    import jakarta.servlet.http.HttpServletResponse;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.access.AccessDeniedException;
    import org.springframework.security.core.context.SecurityContextHolder;
    import org.springframework.security.web.access.AccessDeniedHandler;

    import java.io.IOException;

    public class CustomAccessDeniedHandler implements AccessDeniedHandler {

        @Autowired
        private SecurityLogService securityLogService;

        @Override
        public void handle(
                HttpServletRequest request,
                HttpServletResponse response,
                AccessDeniedException exc) throws IOException {

            response.sendError(403, "Access Denied!");

            var action = SecurityAction.ACCESS_DENIED;
            String subject = SecurityContextHolder.getContext().getAuthentication().getName();
            String object = request.getRequestURI();
            String path = request.getRequestURI();
            SecurityLog log = new SecurityLog(action, subject, object, path);
            securityLogService.saveLog(log);
        }
    }
  learner_created: true
- name: src/account/security/RestAuthenticationEntryPoint.java
  visible: true
  text: |
    package account.security;

    import jakarta.servlet.ServletException;
    import jakarta.servlet.http.HttpServletRequest;
    import jakarta.servlet.http.HttpServletResponse;
    import org.springframework.security.core.AuthenticationException;
    import org.springframework.security.web.AuthenticationEntryPoint;
    import org.springframework.stereotype.Component;

    import java.io.IOException;

    @Component
    public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint {

        @Override
        public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, authException.getMessage());
        }
    }
  learner_created: true
- name: src/account/exceptions/auth/BreachedPasswordException.java
  visible: true
  text: |
    package account.exceptions.auth;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "The password is in the hacker's database!")
    public class BreachedPasswordException extends RuntimeException {
    }
  learner_created: true
- name: src/account/repositories/UserRepository.java
  visible: true
  text: |
    package account.repositories;

    import account.models.User;
    import org.springframework.data.repository.CrudRepository;

    import java.util.List;
    import java.util.Optional;

    public interface UserRepository extends CrudRepository<User, Long> {

        Optional<User> findByEmailIgnoreCase(String email);

        List<User> findAllByOrderByIdAsc();
    }
  learner_created: true
- name: src/account/exceptions/auth/UserNotExistsException.java
  visible: true
  text: |
    package account.exceptions.auth;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "User does not exist!")
    public class UserNotExistsException extends RuntimeException {
    }
  learner_created: true
- name: src/account/services/LoginAttemptService.java
  visible: true
  text: |
    package account.services;

    import account.enums.SecurityAction;
    import account.models.SecurityLog;
    import account.models.User;
    import account.repositories.UserRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.stereotype.Service;

    import java.util.HashMap;
    import java.util.Map;
    import java.util.Optional;

    @Service
    public class LoginAttemptService {

        private static final int MAX_ATTEMPTS = 4;
        private Map<String, Integer> attempts;
        @Autowired
        private SecurityLogService securityLogService;
        @Autowired
        private UserRepository userRepository;

        public LoginAttemptService() {
            super();
            attempts = new HashMap<>();
        }

        public void loginFailed(final String userEmail, String URI) {
            saveLoginFailedLog(userEmail, URI);
            Optional<User> userOpt = userRepository.findByEmailIgnoreCase(userEmail);

            if(userOpt.isEmpty()) {
                return;
            }
            User user = userOpt.get();
            if(user.isAdmin()) {
                return;
            }
            if(!user.isAccountNonLocked()) {
                return;
            }

            int usrAttempts = attempts.getOrDefault(userEmail, 0);
            usrAttempts++;
            attempts.put(userEmail, usrAttempts);
            System.out.println(usrAttempts);
            if(usrAttempts > MAX_ATTEMPTS) {
                saveBruteForceLog(userEmail, URI);
                user.setAccountNonLocked(false);
                saveLockUserLog(userEmail, URI);
                userRepository.save(user);
            }
        }

        public void loginSuccessful(final String userEmail) {
            attempts.put(userEmail, 0);
        }

        private void saveLoginFailedLog(final String userEmail, String URI) {
            var action = SecurityAction.LOGIN_FAILED;
            String subject = userEmail;
            String object = URI;
            String path = URI;
            SecurityLog log = new SecurityLog(action, subject, object, path);

            securityLogService.saveLog(log);
        }

        private void saveBruteForceLog(final String userEmail, String URI) {
            var action = SecurityAction.BRUTE_FORCE;
            String subject = userEmail;
            String object = URI;
            String path = URI;
            SecurityLog log = new SecurityLog(action, subject, object, path);

            securityLogService.saveLog(log);
        }

        private void saveLockUserLog(final String userEmail, String URI) {
            var action = SecurityAction.LOCK_USER;
            String subject = userEmail;
            String object = "Lock user %s".formatted(userEmail);
            String path = URI;
            SecurityLog log = new SecurityLog(action, subject, object, path);

            securityLogService.saveLog(log);
        }

        @Bean
        public Map<String, Integer> getAttempts() {
            return attempts;
        }
    }
  learner_created: true
- name: src/account/exceptions/auth/PasswordNotChangedException.java
  visible: true
  text: |
    package account.exceptions.auth;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "The passwords must be different!")
    public class PasswordNotChangedException extends RuntimeException{
    }
  learner_created: true
- name: src/account/exceptions/roles/RoleGroupCombinationException.java
  visible: true
  text: |
    package account.exceptions.roles;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "The user cannot combine administrative and business roles!")
    public class RoleGroupCombinationException extends RuntimeException {
    }
  learner_created: true
- name: src/account/models/Payment.java
  visible: true
  text: |
    package account.models;

    import account.DTO.PaymentDTO;
    import jakarta.persistence.*;

    import java.text.ParseException;
    import java.text.SimpleDateFormat;
    import java.util.Date;

    @Entity
    @Table(name = "payments")
    public class Payment {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "users_id")
        private User user;

        @Column
        @Temporal(TemporalType.DATE)
        private Date period;

        @Column
        private Long salary;

        public Payment() {}

        public Payment(PaymentDTO paymentDTO, User user) throws ParseException {
            this.user = user;
            this.period = new SimpleDateFormat("MM-yyyy").parse(paymentDTO.getPeriod());
            this.salary = paymentDTO.getSalary();
        }

        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public User getUser() {
            return user;
        }

        public void setUser(User user) {
            this.user = user;
        }

        public Date getPeriod() {
            try {
                return new SimpleDateFormat("yyyy-MM-dd").parse(this.period.toString());
            } catch (ParseException exception) {
                return this.period;
            }
        }

        public void setPeriod(Date period) {
            this.period = period;
        }

        public Long getSalary() {
            return salary;
        }

        public void setSalary(Long salary) {
            this.salary = salary;
        }
    }
  learner_created: true
- name: db/service_db.trace.db
  visible: true
  text: |
    2023-06-02 00:29:56 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:29:56 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:29:56 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:29:56 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:29:58 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:00 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:00 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:01 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:01 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:03 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:05 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:06 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:21 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:22 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:23 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:26 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:27 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:28 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:29 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:30 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:31 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:32 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:34 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:35 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:36 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:37 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:38 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:39 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:39 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:39 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:41 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:43 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:44 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:45 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:46 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:48 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:49 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:51 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:51 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:52 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:53 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:53 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:54 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:55 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:56 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:57 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:57 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:58 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:58 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:58 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:58 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:59 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:30:59 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:31:00 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:31:01 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
    2023-06-02 00:31:01 jdbc[3]: exception
    org.h2.jdbc.JdbcSQLNonTransientException: The object is already closed [90007-214]
  learner_created: true
- name: src/account/services/SecurityLogService.java
  visible: true
  text: |
    package account.services;

    import account.DTO.RoleDTO;
    import account.DTO.UserActionDTO;
    import account.enums.AccountAction;
    import account.enums.OperationType;
    import account.enums.Roles;
    import account.enums.SecurityAction;
    import account.models.SecurityLog;
    import account.models.User;
    import account.repositories.SecurityLogRepository;
    import account.repositories.UserRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.stereotype.Service;

    import java.util.List;

    @Service
    public class SecurityLogService {

        @Autowired
        private SecurityLogRepository securityLogRepository;
        @Autowired
        private UserRepository userRepository;

        public List<SecurityLog> getLogs() {
            var logs = securityLogRepository.findAllByOrderByIdAsc();
            return logs;
        }

        public void saveCreateUserLog(User user) {
            var action = SecurityAction.CREATE_USER;
            String subject = "Anonymous";
            String object = user.getEmail();
            String path = "/api/auth/signup";
            SecurityLog log = new SecurityLog(action, subject, object, path);

            securityLogRepository.save(log);
        }

        public void saveChangePasswordLog(User user) {
            var action = SecurityAction.CHANGE_PASSWORD;
            String subject = user.getEmail();
            String object = user.getEmail();
            String path = "/api/auth/changepass";
            SecurityLog log = new SecurityLog(action, subject, object, path);

            securityLogRepository.save(log);
        }

        public void saveRoleChangedLog(UserDetails adminDetails, User user, RoleDTO roleDTO) {
            OperationType op = roleDTO.getOperation();
            var action = op == OperationType.GRANT ? SecurityAction.GRANT_ROLE : SecurityAction.REMOVE_ROLE;
            String subject = adminDetails.getUsername();
            Roles role = AdminService.parseRole(roleDTO.getRole());
            String object = "%s role %s %s %s".formatted(op.inLowerCaseExceptFirst(), role.noPrefix(),
                    op.getToFrom(), user.getEmail());
            String path = "/api/admin/user/role";
            SecurityLog log = new SecurityLog(action, subject, object, path);

            securityLogRepository.save(log);
        }

        public void saveAccountLockLog(UserDetails adminDetails, User user, UserActionDTO userActionDTO) {
            AccountAction op = userActionDTO.getOperation();
            var action = op == AccountAction.LOCK ? SecurityAction.LOCK_USER : SecurityAction.UNLOCK_USER;
            String subject = adminDetails.getUsername();
            String object = "%s user %s".formatted(op.inLowerCaseExceptFirst(), user.getEmail());
            String path = "/api/admin/user/access";
            SecurityLog log = new SecurityLog(action, subject, object, path);

            securityLogRepository.save(log);
        }

        public void saveAccountDeletedLog(UserDetails adminDetails, User user) {
            var action = SecurityAction.DELETE_USER;
            String subject = adminDetails.getUsername();
            String object = user.getEmail();
            String path = "/api/admin/user";
            SecurityLog log = new SecurityLog(action, subject, object, path);

            securityLogRepository.save(log);
        }

        public void saveLog(SecurityLog log) {
            securityLogRepository.save(log);
        }
    }
  learner_created: true
- name: src/account/DTO/AuthPaymentDTO.java
  visible: true
  text: |
    package account.DTO;

    import account.models.Payment;

    import java.text.DateFormat;
    import java.text.SimpleDateFormat;
    import java.util.Date;
    import java.util.Locale;

    public class AuthPaymentDTO {

        private String name;
        private String lastname;
        private String period;
        private String salary;

        public AuthPaymentDTO() {
        }

        public AuthPaymentDTO(String name, String lastname, Date period, Long salary) {
            this.name = name;
            this.lastname = lastname;
            this.period = this.format(period);
            this.salary = this.format(salary);
        }

        public AuthPaymentDTO(Payment payment) {
            this.name = payment.getUser().getName();
            this.lastname = payment.getUser().getLastName();
            this.period = this.format(payment.getPeriod());
            this.salary = this.format(payment.getSalary());
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getLastname() {
            return lastname;
        }

        public void setLastname(String lastname) {
            this.lastname = lastname;
        }

        public String getPeriod() {
            return period;
        }

        public void setPeriod(String period) {
            this.period = period;
        }

        public String getSalary() {
            return salary;
        }

        public void setSalary(String salary) {
            this.salary = salary;
        }

        private String format(Long salary) {
            long copy = salary;

            int dollars = (int) (copy / 100);
            copy -= dollars * 100;
            int cents = (int) copy;
            return "%d dollar(s) %d cent(s)".formatted(dollars, cents);
        }

        private String format(Date date) {
            DateFormat dateFormat = new SimpleDateFormat("MMMM-yyyy", Locale.US);
            return dateFormat.format(date);
        }
    }
  learner_created: true
- name: src/account/exceptions/roles/RoleAlreadyAllocatedException.java
  visible: true
  text: |
    package account.exceptions.roles;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "User already has this role!")
    public class RoleAlreadyAllocatedException extends RuntimeException {
    }
  learner_created: true
- name: src/account/DTO/PaymentDTO.java
  visible: true
  text: |
    package account.DTO;

    import com.fasterxml.jackson.annotation.JsonProperty;
    import jakarta.validation.constraints.Pattern;
    import jakarta.validation.constraints.PositiveOrZero;

    public class PaymentDTO {

        @Pattern(regexp = ".+@acme.com\\b", message = "Address e-mail not valid!")
        @JsonProperty("employee")
        private String email;

        @Pattern(regexp = "\\b(0[1-9]|1[0-2])-(19[0-9]{2}|20[0-9]{2})\\b", message = "Date format not valid!")
        private String period;

        @PositiveOrZero(message = "Salary cannot be negative!")
        private Long salary;

        public String getEmail() {
            return email;
        }

        public void setEmail(String email) {
            this.email = email;
        }

        public String getPeriod() {
            return period;
        }

        public void setPeriod(String period) {
            this.period = period;
        }

        public Long getSalary() {
            return salary;
        }

        public void setSalary(Long salary) {
            this.salary = salary;
        }
    }
  learner_created: true
- name: src/account/DTO/NewPasswordDTO.java
  visible: true
  text: |
    package account.DTO;

    import com.fasterxml.jackson.annotation.JsonProperty;
    import jakarta.validation.constraints.NotEmpty;
    import jakarta.validation.constraints.Size;

    public class NewPasswordDTO {

        @Size(min = 12, message = "Password length must be 12 chars minimum!")
        @NotEmpty
        @JsonProperty("new_password")
        private String password;

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }
    }
  learner_created: true
- name: src/account/security/AuthenticationFailureListener.java
  visible: true
  text: |
    package account.security;

    import account.services.LoginAttemptService;
    import jakarta.servlet.http.HttpServletRequest;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.ApplicationListener;
    import org.springframework.security.authentication.event.AuthenticationFailureBadCredentialsEvent;
    import org.springframework.stereotype.Component;

    @Component
    public class AuthenticationFailureListener
            implements ApplicationListener<AuthenticationFailureBadCredentialsEvent> {

        @Autowired
        private HttpServletRequest request;

        @Autowired
        private LoginAttemptService loginAttemptService;

        @Override
        public void onApplicationEvent(AuthenticationFailureBadCredentialsEvent event) {
            final String username = event.getAuthentication().getName();
            if (username != null) {
                loginAttemptService.loginFailed(username, request.getRequestURI());
            }
        }
    }
  learner_created: true
- name: src/account/exceptions/auth/LockAdminException.java
  visible: true
  text: |
    package account.exceptions.auth;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "Can't lock the ADMINISTRATOR!")
    public class LockAdminException extends RuntimeException {
    }
  learner_created: true
- name: src/account/repositories/PaymentRepository.java
  visible: true
  text: |
    package account.repositories;

    import account.models.Payment;
    import org.springframework.data.repository.CrudRepository;

    import java.util.Date;
    import java.util.List;
    import java.util.Optional;

    public interface PaymentRepository extends CrudRepository<Payment, Long> {

        List<Payment> findByUserId(Long userId);

        List<Payment> findByUserIdOrderByPeriodDesc(Long userId);

        Optional<Payment> findByUserIdAndPeriod(Long userId, Date period);
    }
  learner_created: true
- name: src/account/controllers/SecurityController.java
  visible: true
  text: |
    package account.controllers;

    import account.services.SecurityLogService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.access.prepost.PreAuthorize;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;

    @RestController
    @RequestMapping("/api/security")
    public class SecurityController {

        @Autowired
        private SecurityLogService securityLogService;

        @GetMapping(value = {"/events", "/events/"})
        @PreAuthorize("hasAuthority('ROLE_AUDITOR')")
        public ResponseEntity getLogs() {
            var logs = securityLogService.getLogs();
            return ResponseEntity.ok(logs);
        }
    }
  learner_created: true
- name: src/account/DTO/UserDTO.java
  visible: true
  text: |
    package account.DTO;

    import jakarta.validation.constraints.NotEmpty;
    import jakarta.validation.constraints.Pattern;
    import jakarta.validation.constraints.Size;

    public class UserDTO {

        @NotEmpty
        private String name;

        @NotEmpty
        private String lastname;

        @NotEmpty
        @Pattern(regexp = ".+@acme.com\\b", message = "Address e-mail not valid!")
        private String email;

        @NotEmpty
        @Size(min = 12, message = "Password length must be 12 chars minimum!")
        private String password;

        public UserDTO() {
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getLastname() {
            return lastname;
        }

        public void setLastname(String lastname) {
            this.lastname = lastname;
        }

        public String getEmail() {
            return email;
        }

        public void setEmail(String email) {
            this.email = email;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }
    }
  learner_created: true
- name: src/account/controllers/AuthController.java
  visible: true
  text: |
    package account.controllers;

    import account.DTO.NewPasswordDTO;
    import account.DTO.UserDTO;
    import account.models.User;
    import account.services.AuthService;
    import account.services.SecurityLogService;
    import jakarta.validation.Valid;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.access.prepost.PreAuthorize;
    import org.springframework.security.core.annotation.AuthenticationPrincipal;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;

    import java.util.Map;

    @RestController
    @RequestMapping("/api/auth")
    public class AuthController {

        @Autowired
        private AuthService authService;
        @Autowired
        private SecurityLogService securityLogService;

        @PostMapping(value = {"/signup", "/signup/"})
        public ResponseEntity registerUser(@RequestBody @Valid UserDTO userDTO) {
            User user = authService.registerUser(userDTO);
            securityLogService.saveCreateUserLog(user);
            return ResponseEntity.ok(user);
        }

        @PostMapping(value = {"/changepass", "/changepass/"})
        @PreAuthorize("hasAuthority('ROLE_USER') or hasAuthority('ROLE_ACCOUNTANT') or hasAuthority('ROLE_ADMINISTRATOR')")
        public ResponseEntity changePassword(@AuthenticationPrincipal UserDetails details,
                                             @RequestBody @Valid NewPasswordDTO passwordDTO) {
            User user = authService.changePassword(details, passwordDTO);
            securityLogService.saveChangePasswordLog(user);
            return ResponseEntity.ok(Map.of("email", details.getUsername(),
                    "status", "The password has been updated successfully"));
        }
    }
  learner_created: true
- name: src/account/models/BreachedPassword.java
  visible: true
  text: |
    package account.models;

    import jakarta.persistence.*;

    @Entity
    @Table(name = "breached_passwords")
    public class BreachedPassword {

        @Id
        private Long id;
        private String password;

        public BreachedPassword() {}

        public BreachedPassword(Long id, String password) {
            this.password = password;
            this.id = id;
        }

        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }
    }
  learner_created: true
- name: src/account/security/AuthenticationSuccessListener.java
  visible: true
  text: |
    package account.security;

    import account.services.LoginAttemptService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.ApplicationListener;
    import org.springframework.security.authentication.event.AuthenticationSuccessEvent;
    import org.springframework.stereotype.Component;

    @Component
    public class AuthenticationSuccessListener
            implements ApplicationListener<AuthenticationSuccessEvent> {

        @Autowired
        private LoginAttemptService loginAttemptService;

        @Override
        public void onApplicationEvent(AuthenticationSuccessEvent event) {
            final String username = event.getAuthentication().getName();
            loginAttemptService.loginSuccessful(username);
        }
    }
  learner_created: true
- name: src/account/enums/SecurityAction.java
  visible: true
  text: |
    package account.enums;

    public enum SecurityAction {
        CREATE_USER,
        CHANGE_PASSWORD,
        ACCESS_DENIED,
        LOGIN_FAILED,
        GRANT_ROLE,
        REMOVE_ROLE,
        LOCK_USER,
        UNLOCK_USER,
        DELETE_USER,
        BRUTE_FORCE
    }
  learner_created: true
- name: src/account/security/UserDetailsImpl.java
  visible: true
  text: |
    package account.security;

    import account.enums.Roles;
    import account.models.User;
    import org.springframework.security.core.GrantedAuthority;
    import org.springframework.security.core.authority.SimpleGrantedAuthority;
    import org.springframework.security.core.userdetails.UserDetails;

    import java.util.ArrayList;
    import java.util.Collection;
    import java.util.List;

    public class UserDetailsImpl implements UserDetails {

        private final String username;
        private final String password;
        private boolean nonLocked;
        private final List<GrantedAuthority> rolesAndAuthorities;

        public UserDetailsImpl(User user) {
            this.username = user.getEmail();
            this.password = user.getPassword();
            this.nonLocked = user.isAccountNonLocked();

            this.rolesAndAuthorities = new ArrayList<>();
            for(Roles role : user.getRoles()) {
                rolesAndAuthorities.add(new SimpleGrantedAuthority(role.toString()));
            }
        }

        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() {
            return rolesAndAuthorities;
        }

        @Override
        public String getPassword() {
            return this.password;
        }

        @Override
        public String getUsername() {
            return this.username;
        }

        @Override
        public boolean isAccountNonExpired() {
            return true;
        }

        @Override
        public boolean isAccountNonLocked() {
            return this.nonLocked;
        }

        @Override
        public boolean isCredentialsNonExpired() {
            return true;
        }

        @Override
        public boolean isEnabled() {
            return true;
        }
    }
  learner_created: true
- name: src/resources/data-test.sql
  visible: true
  text: |-
    DELETE FROM breached_passwords;
    INSERT INTO breached_passwords (id, password) VALUES
    (1, 'PasswordForJanuary'),
    (2, 'PasswordForFebruary'),
    (3, 'PasswordForMarch'),
    (4, 'PasswordForApril'),
    (5, 'PasswordForMay'),
    (6, 'PasswordForJune'),
    (7, 'PasswordForJuly'),
    (8, 'PasswordForAugust'),
    (9, 'PasswordForSeptember'),
    (10, 'PasswordForOctober'),
    (11, 'PasswordForNovember'),
    (12, 'PasswordForDecember');
  learner_created: true
- name: src/account/models/SecurityLog.java
  visible: true
  text: |
    package account.models;

    import account.enums.Roles;
    import account.enums.SecurityAction;
    import com.fasterxml.jackson.annotation.JsonIgnore;
    import com.fasterxml.jackson.annotation.JsonPropertyOrder;
    import jakarta.persistence.*;

    import java.util.Date;

    @Table(name = "logs")
    @Entity
    @JsonPropertyOrder({"date", "action", "subject", "object", "path"})
    public class SecurityLog {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        @JsonIgnore
        private Long id;
        @Temporal(TemporalType.DATE)
        private Date date;
        @Enumerated(EnumType.STRING)
        private SecurityAction action;
        private String subject;
        private String object;
        private String path;

        public SecurityLog() {
        }

        public SecurityLog(SecurityAction action, String subject, String object, String path) {
            this.date = new Date();
            this.action = action;
            this.subject = subject;
            this.object = object;
            this.path = path;
        }

        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public Date getDate() {
            return date;
        }

        public void setDate(Date date) {
            this.date = date;
        }

        public String getSubject() {
            return subject;
        }

        public void setSubject(String subject) {
            this.subject = subject;
        }

        public String getObject() {
            return object;
        }

        public void setObject(String object) {
            this.object = object;
        }

        public String getPath() {
            return path;
        }

        public SecurityAction getAction() {
            return action;
        }

        public void setAction(SecurityAction action) {
            this.action = action;
        }

        public void setPath(String path) {
            this.path = path;
        }
    }
  learner_created: true
- name: src/account/enums/OperationType.java
  visible: true
  text: |
    package account.enums;

    public enum OperationType {
        GRANT("to"), REMOVE("from");

        private String toFrom;

        OperationType(String toFrom) {
            this.toFrom = toFrom;
        }

        public String getToFrom() {
            return toFrom;
        }

        public String inLowerCaseExceptFirst() {
            StringBuilder sb = new StringBuilder("");
            sb.append(this.toString().charAt(0));
            sb.append(this.toString().substring(1, this.toString().length()).toLowerCase());
            return sb.toString();
        }
    }
  learner_created: true
- name: src/account/repositories/BreachedPasswordsRepository.java
  visible: true
  text: |
    package account.repositories;

    import account.models.BreachedPassword;
    import org.springframework.data.repository.CrudRepository;

    import java.util.Optional;

    public interface BreachedPasswordsRepository extends CrudRepository<BreachedPassword, Long> {

        Optional<BreachedPassword> findByPassword(String password);
    }
  learner_created: true
- name: src/account/enums/AccountAction.java
  visible: true
  text: |
    package account.enums;

    public enum AccountAction {
        LOCK(false), UNLOCK(true);

        private boolean accountShouldBeNonLocked;

        AccountAction(boolean accountShouldBeNonLocked) {
            this.accountShouldBeNonLocked = accountShouldBeNonLocked;
        }

        public boolean accountShouldBeNonLocked() {
            return accountShouldBeNonLocked;
        }

        public String inLowerCaseExceptFirst() {
            StringBuilder sb = new StringBuilder("");
            sb.append(this.toString().charAt(0));
            sb.append(this.toString().substring(1, this.toString().length()).toLowerCase());
            return sb.toString();
        }
    }
  learner_created: true
- name: src/account/services/AdminService.java
  visible: true
  text: |
    package account.services;

    import account.DTO.RoleDTO;
    import account.DTO.UserActionDTO;
    import account.enums.OperationType;
    import account.enums.Roles;
    import account.exceptions.auth.LockAdminException;
    import account.exceptions.auth.UserNotFoundException;
    import account.exceptions.roles.*;
    import account.models.User;
    import account.repositories.UserRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;

    import java.util.List;
    import java.util.Map;

    @Service
    public class AdminService {

        @Autowired
        private UserRepository userRepository;
        @Autowired
        private Map<String, Integer> attempts;

        public List<User> getUsersList() {
            List<User> users = userRepository.findAllByOrderByIdAsc();
            return users;
        }

        public User deleteUser(String email) {
            User user = getUserOrElseThrow(email);
            if (user.isAdmin()) {
                throw new AdminDeletionException();
            }
            userRepository.delete(user);
            return user;
        }

        public User changeRole(RoleDTO roleDTO) {
            User user = getUserOrElseThrow(roleDTO.getEmail());
            OperationType op = roleDTO.getOperation();
            Roles role = parseRole(roleDTO.getRole());

            checkConditions(op, user, role);

            if (op == OperationType.GRANT) {
                user.addRole(role);
                userRepository.save(user);
                return user;
            }

            user.removeRole(role);
            userRepository.save(user);
            return user;
        }

        public User lockUnlockUser(UserActionDTO userActionDTO) {
            User user = getUserOrElseThrow(userActionDTO.getEmail());
            adminLockCondition(user);

            user.setAccountNonLocked(userActionDTO.getOperation().accountShouldBeNonLocked());
            if(userActionDTO.getOperation().accountShouldBeNonLocked() == true) {
                attempts.put(user.getEmail(), 0);
            }
            userRepository.save(user);
            return user;
        }

        public static Roles parseRole(String role) {
            Roles roleEnum = null;
            try {
                roleEnum = Roles.valueOf("ROLE_" + role);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            return roleEnum;
        }

        private User getUserOrElseThrow(String email) {
            return userRepository.findByEmailIgnoreCase(email)
                    .orElseThrow(() -> new UserNotFoundException());
        }

        private void checkConditions(OperationType op, User user, Roles role) {
            if (op == OperationType.REMOVE) {
                unpossessedRoleRemovalCondition(user, role);
                adminDeleteCondition(user);
                tooLittleRolesCondition(user);
                return;
            }
            roleGroupComboCondition(user, role);
            roleAllocatedCondition(user, role);
        }

        private void unpossessedRoleRemovalCondition(User user, Roles role) throws RoleNotFoundException {
            if (!user.hasRole(role)) {
                throw new RoleNotFoundException();
            }
        }

        private void adminDeleteCondition(User user) throws AdminDeletionException {
            if (user.isAdmin()) {
                throw new RoleNotFoundException();
            }
        }

        private void adminLockCondition(User user) {
            if(user.isAdmin()) {
                throw new LockAdminException();
            }
        }

        private void tooLittleRolesCondition(User user) throws TooLittleRolesException {
            if (user.rolesCount() == 1) {
                throw new TooLittleRolesException();
            }
        }

        private void roleGroupComboCondition(User user, Roles role) throws RoleGroupCombinationException {
            if ((role.isAdmin() && !user.isAdmin())
                    || (!role.isAdmin() && user.isAdmin())) {
                throw new RoleGroupCombinationException();
            }
        }

        private void roleAllocatedCondition(User user, Roles role) throws RoleAlreadyAllocatedException {
            if (user.hasRole(role)) {
                throw new RoleAlreadyAllocatedException();
            }
        }
    }
  learner_created: true
- name: src/account/exceptions/auth/UserExistsException.java
  visible: true
  text: |
    package account.exceptions.auth;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "User exist!")
    public class UserExistsException extends RuntimeException {
    }
  learner_created: true
- name: src/account/controllers/BusinessController.java
  visible: true
  text: |
    package account.controllers;

    import account.DTO.AuthPaymentDTO;
    import account.DTO.PaymentDTO;
    import account.services.BusinessService;
    import jakarta.validation.Valid;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.access.prepost.PreAuthorize;
    import org.springframework.security.core.annotation.AuthenticationPrincipal;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.validation.annotation.Validated;
    import org.springframework.web.bind.annotation.*;

    import java.util.List;
    import java.util.Map;

    @RestController
    @Validated
    public class BusinessController {

        @Autowired
        private BusinessService businessService;

        @GetMapping(value = {"/api/empl/payment", "/api/empl/payment/"}, params = "period")
        @PreAuthorize("hasAuthority('ROLE_USER') or hasAuthority('ROLE_ACCOUNTANT')")
        public ResponseEntity getPayroll(@AuthenticationPrincipal UserDetails userDetails, @RequestParam String period) {
            AuthPaymentDTO authPaymentDTO = businessService.getPayrolls(userDetails, period);
            return ResponseEntity.ok(authPaymentDTO);
        }

        @GetMapping(value = {"/api/empl/payment", "/api/empl/payment/"})
        @PreAuthorize("hasAuthority('ROLE_USER') or hasAuthority('ROLE_ACCOUNTANT')")
        public ResponseEntity getPayroll(@AuthenticationPrincipal UserDetails userDetails) {
            List<AuthPaymentDTO> payments = businessService.getPayrolls(userDetails);
            return ResponseEntity.ok(payments);
        }

        @PostMapping(value = {"/api/acct/payments", "/api/acct/payments/"})
        @PreAuthorize("hasAuthority('ROLE_ACCOUNTANT')")
        public ResponseEntity uploadPayroll(@RequestBody List<@Valid PaymentDTO> paymentDTOS) {
            businessService.uploadPayrolls(paymentDTOS);
            return ResponseEntity.ok(Map.of("status", "Added successfully!"));
        }

        @PutMapping(value = {"/api/acct/payments", "/api/acct/payments/"})
        @PreAuthorize("hasAuthority('ROLE_ACCOUNTANT')")
        public ResponseEntity updatePayment(@RequestBody @Valid PaymentDTO paymentDTO) {
            businessService.updatePayment(paymentDTO);
            return ResponseEntity.ok(Map.of("status", "Updated successfully!"));
        }
    }
  learner_created: true
- name: src/resources/keystore/keystore.p12
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/16607#comment
status: Unchecked
record: -1
